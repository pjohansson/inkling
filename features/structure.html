<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Story structure - Inkling</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="User guide for &#x60;inkling&#x60;">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Inkling</a></li><li class="chapter-item expanded "><a href="../introduction/summary.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/what-is-ink.html"><strong aria-hidden="true">1.1.</strong> What is Ink?</a></li><li class="chapter-item expanded "><a href="../introduction/what-is-inkling.html"><strong aria-hidden="true">1.2.</strong> What is Inkling?</a></li><li class="chapter-item expanded "><a href="../introduction/example.html"><strong aria-hidden="true">1.3.</strong> Short example</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Using Inkling</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.1.</strong> Design intent</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> Reading a script</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.</strong> Helper functions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> Saving and loading</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.5.</strong> Example: Text adventure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.6.</strong> Example: Dialogue trees</div></li></ol></li><li class="chapter-item expanded "><a href="../features/summary.html"><strong aria-hidden="true">3.</strong> Implemented Ink features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../features/basic.html"><strong aria-hidden="true">3.1.</strong> Basic elements</a></li><li class="chapter-item expanded "><a href="../features/structure.html" class="active"><strong aria-hidden="true">3.2.</strong> Story structure</a></li><li class="chapter-item expanded "><a href="../features/variables.html"><strong aria-hidden="true">3.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../features/conditional-content.html"><strong aria-hidden="true">3.4.</strong> Conditional content</a></li><li class="chapter-item expanded "><a href="../features/sequences.html"><strong aria-hidden="true">3.5.</strong> Alternating sequences</a></li><li class="chapter-item expanded "><a href="../features/metadata.html"><strong aria-hidden="true">3.6.</strong> Story metadata</a></li><li class="chapter-item expanded "><a href="../features/missing-features.html"><strong aria-hidden="true">3.7.</strong> Missing features</a></li></ol></li><li class="chapter-item expanded "><a href="../back-matter/compatibility.html">In regards to compatibility</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Inkling</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#story-structure" id="story-structure">Story structure</a></h1>
<p>Story scripts can be divided into different sections, to which the story can diverge.
This section introduces how to create these sections and move to them in the text.</p>
<h2><a class="header" href="#knots" id="knots">Knots</a></h2>
<p>A story can be divided into different sections, called <em>knots</em> in <code>Ink</code>. This division
is invisible to the user but makes it easier to write and reason about the story
in production.</p>
<p>A knot is denoted by beginning the line with at least two (2) <code>=</code> signs followed by
a name for the knot. On the following lines, the story text can resume.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::read_story_from_string;
</span><span class="boring">let content = r&quot;
</span><span class="boring">
</span>== stairwell
I made my way down the empty stairwell.
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">assert!(story.move_to(&quot;stairwell&quot;, None).is_ok());
</span><span class="boring">}
</span></code></pre></pre>
<p>The name (’stairwell’ in the previous example) cannot contain spaces or non-alphanumeric
symbols. Optionally, it may be followed by more <code>=</code> signs, which are not necessary but may
make it easier to identify knots in the document. This is identical to the previous
example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::read_story_from_string;
</span><span class="boring">let content = r&quot;
</span><span class="boring">
</span>=== stairwell ===
I made my way down the empty stairwell.
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">assert!(story.move_to(&quot;stairwell&quot;, None).is_ok());
</span><span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#non-latin-characters" id="non-latin-characters">Non-latin characters</a></h3>
<p>Knot names support any character as long as they are
<a href="https://doc.rust-lang.org/std/primitive.char.html#method.is_alphanumeric">alphanumeric</a>
according to the <code>Rust</code> language specification. This seems to include all languages
which are recognized by UTF-8. Thus, knots (and any identifer) may contain e.g.
Chinese, Japanese, Arabic, Cyrillic and other characters. Do let us know if you
find any exceptions.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::read_story_from_string;
</span><span class="boring">let content = r&quot;
</span><span class="boring">
</span>=== عقدة ===
These

=== 매듭 ===
are

=== गांठ ===
all

=== 結 ===
allowed.
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">assert!(story.move_to(&quot;عقدة&quot;, None).is_ok());
</span><span class="boring">assert!(story.move_to(&quot;매듭&quot;, None).is_ok());
</span><span class="boring">assert!(story.move_to(&quot;गांठ&quot;, None).is_ok());
</span><span class="boring">assert!(story.move_to(&quot;結&quot;, None).is_ok());
</span><span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#stitches" id="stitches">Stitches</a></h2>
<p>Knots may be further subdivided into <em>stitches</em>. These are denoted by single <code>=</code> markers.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::read_story_from_string;
</span><span class="boring">let content = r&quot;
</span><span class="boring">
</span>=== garden ===
= entrance
A pale moonlight illuminated the garden.

= well
The well stank of stagnant water. Is that an eel I see at the bottom?
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">assert!(story.move_to(&quot;garden&quot;, Some(&quot;entrance&quot;)).is_ok());
</span><span class="boring">assert!(story.move_to(&quot;garden&quot;, Some(&quot;well&quot;)).is_ok());
</span><span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#diverts" id="diverts">Diverts</a></h2>
<p><em>Diverts</em> are used to move to different parts of the story. A divert to a <em>knot</em> moves
the story to continue from there. They are designated with the <code>-&gt;</code> marker followed
by the destination.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::read_story_from_string;
</span><span class="boring">let content = r&quot;
</span><span class="boring">-&gt; stairwell
</span><span class="boring">
</span>=== stairwell ===
The stairs creaked as I descended.
-&gt; lower_floor

=== garden ===
A pale moonlight illuminated the garden as I entered it.
-&gt; END

=== lower_floor ===
On the bottom I found an unlocked door.
-&gt; garden
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">let mut buffer = Vec::new();
</span><span class="boring">story.start().unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap();
</span><span class="boring">assert_eq!(story.get_current_location().unwrap(), (&quot;garden&quot;.to_string(), None));
</span><span class="boring">}
</span></code></pre></pre>
<p>Diverts are automatically followed as they are encountered.</p>
<h3><a class="header" href="#diverts-to-stitches" id="diverts-to-stitches">Diverts to stitches</a></h3>
<p>Stitches inside knots can be diverted to using <code>knot.stitch</code> as a destination:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::read_story_from_string;
</span><span class="boring">let content = r&quot;
</span><span class="boring">
</span>-&gt; garden.entrance
<span class="boring">
</span><span class="boring">=== garden ===
</span><span class="boring">= well
</span><span class="boring">Unreachable.
</span><span class="boring">= entrance
</span><span class="boring">A pale moonlight illuminated the garden.
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">let mut buffer = Vec::new();
</span><span class="boring">story.start().unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap();
</span><span class="boring">assert!(buffer[0].text.starts_with(&quot;A pale moonlight illuminated the garden.&quot;));
</span><span class="boring">}
</span></code></pre></pre>
<p>Stitches within the same knot can be diverted to with only the stitch name:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::read_story_from_string;
</span><span class="boring">let content = r&quot;
</span><span class="boring">-&gt; garden
</span><span class="boring">
</span>=== garden ===
-&gt; well

= entrance
A pale moonlight illuminated the garden.

= well
The well stank of stagnant water.
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">let mut buffer = Vec::new();
</span><span class="boring">story.start().unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap();
</span><span class="boring">assert!(buffer[0].text.starts_with(&quot;The well stank of stagnant water.&quot;));
</span><span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#ending-the-story-with---end" id="ending-the-story-with---end">Ending the story with <code>-&gt; END</code></a></h3>
<p><code>END</code> is a destination that signifies that the story has come to, well, an end. Use
<code>-&gt; END</code> diverts for such occasions. An <code>ink</code> story is not complete unless all
branches one way or another leads to an <code>-&gt; END</code> divert: ending a story should
be intentional.</p>
<h2><a class="header" href="#diverts-in-choices" id="diverts-in-choices">Diverts in choices</a></h2>
<p>A common use of branches is to divert to other knots.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::read_story_from_string;
</span><span class="boring">let content = r&quot;
</span><span class="boring">
</span>*   [Descend stairs] -&gt; lower_floor
*   [Return to desk]
    I sighed, wearily, and returned to my room.
    -&gt; desk

=== desk ===
As I sat by my desk, I noticed that my notebook had gone missing.

=== lower_floor ===
On the bottom I found an unlocked door.
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">let mut buffer = Vec::new();
</span><span class="boring">story.start().unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap();
</span><span class="boring">story.make_choice(1).unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap();
</span><span class="boring">assert_eq!(story.get_current_location().unwrap(), (&quot;desk&quot;.to_string(), None));
</span><span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#revisiting-content-and-choices" id="revisiting-content-and-choices">Revisiting content and choices</a></h2>
<p>With diverts we can easily return to previously visited knots and stitches. When 
this happens, the text is reevaluated to reflect the current state of the story
(see the sections on <a href="conditional-content.html">conditional content</a> and 
<a href="sequences.html">alternating sequences</a> for more information).</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::read_story_from_string;
</span><span class="boring">let content = r&quot;
</span><span class="boring">
</span>=== table ===
You are seated at the table.

*   [Order a cup of tea] 
    A waiter returns with a steaming hot cup of tea. 
    -&gt; table
*   [Leave]
    You leave the café.
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">assert!(read_story_from_string(content).is_ok());
</span><span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#once-only-and-sticky-choices" id="once-only-and-sticky-choices">Once-only and sticky choices</a></h3>
<p>Any set of branching choices will also be reevaluated. There are two types of 
choices, denoted by if they begin with <code>*</code> or <code>+</code> markers:</p>
<ul>
<li><code>*</code> marks <em>once-only</em> choices, which can only be picked once</li>
<li><code>+</code> marks <em>sticky</em> choices, which can be picked any number of times</li>
</ul>
<p>In short, <em>once-only</em> choices are removed from the choice list if they are picked.
<em>Sticky</em> choices will remain. This has to be kept in mind if the branch might be 
revisited during the story.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::{read_story_from_string, Prompt};
</span><span class="boring">let content = r&quot;
</span><span class="boring">-&gt; loop
</span><span class="boring">
</span>=== loop ===
*   This choice can only be picked once -&gt; loop
+   This choice is always here -&gt; loop
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">let mut buffer = Vec::new();
</span><span class="boring">story.start().unwrap();
</span><span class="boring">match story.resume(&amp;mut buffer).unwrap() {
</span><span class="boring">  Prompt::Choice(choices) =&gt; {
</span><span class="boring">      assert_eq!(choices.len(), 2);
</span><span class="boring">      assert_eq!(&amp;choices[0].text, &quot;This choice can only be picked once&quot;);
</span><span class="boring">  }
</span><span class="boring">  _ =&gt; unreachable!()
</span><span class="boring">}
</span><span class="boring">story.make_choice(0).unwrap();
</span><span class="boring">match story.resume(&amp;mut buffer).unwrap() {
</span><span class="boring">  Prompt::Choice(choices) =&gt; {
</span><span class="boring">      assert_eq!(choices.len(), 1);
</span><span class="boring">      assert_eq!(&amp;choices[0].text, &quot;This choice is always here&quot;);
</span><span class="boring">  }
</span><span class="boring">  _ =&gt; unreachable!()
</span><span class="boring">}
</span><span class="boring">story.make_choice(0).unwrap();
</span><span class="boring">match story.resume(&amp;mut buffer).unwrap() {
</span><span class="boring">  Prompt::Choice(choices) =&gt; {
</span><span class="boring">      assert_eq!(choices.len(), 1);
</span><span class="boring">      assert_eq!(&amp;choices[0].text, &quot;This choice is always here&quot;);
</span><span class="boring">  }
</span><span class="boring">  _ =&gt; unreachable!()
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#running-out-of-choices" id="running-out-of-choices">Running out of choices</a></h3>
<p>Since once-only choices are removed it is possible for a branching choice point
to run out of choices. <strong>This will result in an 
<a href="https://docs.rs/inkling/latest/inkling/enum.InklingError.html#variant.OutOfChoices">error</a> 
being returned from <code>inkling</code> at runtime.</strong></p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::{read_story_from_string, Prompt};
</span><span class="boring">let content = r&quot;
</span><span class="boring">-&gt; thrice_fail
</span><span class="boring">
</span>=== thrice_fail ===
The third time we return here we are out of choices and an error is returned.

*   First choice -&gt; thrice_fail
*   Second choice -&gt; thrice_fail
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">let mut buffer = Vec::new();
</span><span class="boring">story.start().unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap();
</span><span class="boring">story.make_choice(0).unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap();
</span><span class="boring">story.make_choice(0).unwrap();
</span><span class="boring">assert!(story.resume(&amp;mut buffer).is_err());
</span><span class="boring">}
</span></code></pre></pre>
<p>So be careful when writing branching choices using only once-only markers. Is there a 
risk that you will return to it multiple times? </p>
<h3><a class="header" href="#fallback-choices" id="fallback-choices">Fallback choices</a></h3>
<p>There is a fallback option available for running out of choices. If no regular (sticky 
or once-only) choices are left to present for the user, <code>inkling</code> will look for a 
<em>fallback</em> choice and automatically follow it.</p>
<p>This can only be a single choice and is marked by being a choice <em>without choice text</em>,
which is to say that it starts with a divert <code>-&gt;</code> marker.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::{read_story_from_string, Prompt};
</span><span class="boring">let content = r&quot;
</span><span class="boring">-&gt; twice_fail
</span><span class="boring">
</span>=== twice_fail ===
The second time we return here we are out of choices and an error is returned.

*   First choice -&gt; twice_fail
*   -&gt; fallback

=== fallback ===
We escaped the loop!
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">let mut buffer = Vec::new();
</span><span class="boring">story.start().unwrap();
</span><span class="boring">match story.resume(&amp;mut buffer).unwrap() {
</span><span class="boring">  Prompt::Choice(choices) =&gt; {
</span><span class="boring">      assert_eq!(choices.len(), 1);
</span><span class="boring">      assert_eq!(&amp;choices[0].text, &quot;First choice&quot;);
</span><span class="boring">  }
</span><span class="boring">  _ =&gt; unreachable!()
</span><span class="boring">}
</span><span class="boring">story.make_choice(0).unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap(); 
</span><span class="boring">assert_eq!(&amp;buffer.last().unwrap().text, &quot;We escaped the loop!\n&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>The fallback content can contain text by putting it on a new line directly after 
the divert marker.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::{read_story_from_string, Prompt};
</span><span class="boring">let content = r&quot;
</span><span class="boring">-&gt; write_article
</span><span class="boring">
</span>=== write_article ===
*   [Write abstract] -&gt; write_article
*   [Write main text] -&gt; write_article
*   [Write summary] -&gt; write_article
*   -&gt; 
    The article is finished.
    -&gt; submit_article

=== submit_article ===
You submit it to your editor.
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">let mut buffer = Vec::new();
</span><span class="boring">story.start().unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap(); 
</span><span class="boring">story.make_choice(0).unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap(); 
</span><span class="boring">story.make_choice(0).unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap(); 
</span><span class="boring">story.make_choice(0).unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap(); 
</span><span class="boring">assert_eq!(&amp;buffer[0].text, &quot;The article is finished.\n&quot;);
</span><span class="boring">assert_eq!(&amp;buffer[1].text, &quot;You submit it to your editor.\n&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>Fallback choices can also be sticky. If they are not they will also be consumed after
use. Again, ensure that you are sure that branches with non-sticky fallback choices
will not be returned to multiple times.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::{read_story_from_string, Prompt};
</span><span class="boring">let content = r&quot;
</span><span class="boring">
</span>=== once_only_fallback ===
This will return an error if the fallback choice is used twice.
*   -&gt; once_only_fallback 

=== sticky_fallback ===
<span class="boring">{sticky_fallback &gt; 2 : -&gt; END} // exit once we have returned here twice
</span>This sticky fallback choice can be use any number of times.
+   -&gt; sticky_fallback 
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">let mut buffer = Vec::new();
</span><span class="boring">story.start().unwrap();
</span><span class="boring">story.move_to(&quot;once_only_fallback&quot;, None).unwrap();
</span><span class="boring">assert!(story.resume(&amp;mut buffer).is_err());
</span><span class="boring">story.move_to(&quot;sticky_fallback&quot;, None).unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap(); 
</span><span class="boring">assert!(story.resume(&amp;mut buffer).is_ok());
</span><span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gather-points" id="gather-points">Gather points</a></h2>
<p>When creating a set of choices, you can return (or, <em>gather</em>) all of the branches to 
a single path after they have gone through their content. This is done using 
<em>gather points.</em></p>
<p>To return the branches, add a gather marker <code>-</code> at a new line after the branches.</p>
<p>In the following example, regardless of whether the player heads to the garden 
or the kitchen, they return to their room. There, they are presented with the next choice.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::read_story_from_string;
</span><span class="boring">let content = r&quot;
</span><span class="boring">
</span>*   [Head into the garden]
    The chirp of crickets greet you as you enter the garden.
*   [Move to the kitchen]
    A crackling fireplace illuminates the dark room.
-   A while later, you return to your room.
*   [Lay in bed]
*   [Sit at table]
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">let mut story_other = read_story_from_string(content).unwrap();
</span><span class="boring">let mut buffer = Vec::new();
</span><span class="boring">story.start().unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap();
</span><span class="boring">story.make_choice(0).unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap();
</span><span class="boring">assert_eq!(buffer.len(), 2);
</span><span class="boring">assert_eq!(&amp;buffer[0].text, &quot;The chirp of crickets greet you as you enter the garden.\n&quot;);
</span><span class="boring">assert_eq!(&amp;buffer[1].text, &quot;A while later, you return to your room.\n&quot;);
</span><span class="boring">buffer.clear();
</span><span class="boring">story_other.start().unwrap();
</span><span class="boring">story_other.resume(&amp;mut buffer).unwrap();
</span><span class="boring">story_other.make_choice(1).unwrap();
</span><span class="boring">story_other.resume(&amp;mut buffer).unwrap();
</span><span class="boring">assert_eq!(buffer.len(), 2);
</span><span class="boring">assert_eq!(&amp;buffer[0].text, &quot;A crackling fireplace illuminates the dark room.\n&quot;);
</span><span class="boring">assert_eq!(&amp;buffer[1].text, &quot;A while later, you return to your room.\n&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#nested-gather-points" id="nested-gather-points">Nested gather points</a></h3>
<p>Gathers can be performed for any nested level of choices. Simply add the corresponding 
number of gather markers <code>-</code> below.</p>
<p>In this example, both inner choices 1.1 and 1.2 will gather at 1.1. Inner choices 2.1 
and 2.2 at gather 2.1. Then finally, both outer choices 1 and 2 at gather point 1.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::read_story_from_string;
</span><span class="boring">let content = r&quot;
</span><span class="boring">
</span>*   Choice 1
    * *     Choice 1.1
    * *     Choice 1.2
    - -     Gather 1.1
*   Choice 2
    * *     Choice 2.1
    * *     Choice 2.2
    - -     Gather 2.1
-   Gather 1
<span class="boring">
</span><span class="boring">&quot;;
</span><span class="boring">let mut story = read_story_from_string(content).unwrap();
</span><span class="boring">let mut story_other = read_story_from_string(content).unwrap();
</span><span class="boring">let mut buffer = Vec::new();
</span><span class="boring">story.start().unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap();
</span><span class="boring">story.make_choice(1).unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap();
</span><span class="boring">story.make_choice(0).unwrap();
</span><span class="boring">story.resume(&amp;mut buffer).unwrap();
</span><span class="boring">assert_eq!(buffer.len(), 4);
</span><span class="boring">assert_eq!(&amp;buffer[0].text, &quot;Choice 2\n&quot;);
</span><span class="boring">assert_eq!(&amp;buffer[1].text, &quot;Choice 2.1\n&quot;);
</span><span class="boring">assert_eq!(&amp;buffer[2].text, &quot;Gather 2.1\n&quot;);
</span><span class="boring">assert_eq!(&amp;buffer[3].text, &quot;Gather 1\n&quot;);
</span><span class="boring">buffer.clear();
</span><span class="boring">story_other.start().unwrap();
</span><span class="boring">story_other.resume(&amp;mut buffer).unwrap();
</span><span class="boring">story_other.make_choice(0).unwrap();
</span><span class="boring">story_other.resume(&amp;mut buffer).unwrap();
</span><span class="boring">story_other.make_choice(1).unwrap();
</span><span class="boring">story_other.resume(&amp;mut buffer).unwrap();
</span><span class="boring">assert_eq!(buffer.len(), 4);
</span><span class="boring">assert_eq!(&amp;buffer[0].text, &quot;Choice 1\n&quot;);
</span><span class="boring">assert_eq!(&amp;buffer[1].text, &quot;Choice 1.2\n&quot;);
</span><span class="boring">assert_eq!(&amp;buffer[2].text, &quot;Gather 1.1\n&quot;);
</span><span class="boring">assert_eq!(&amp;buffer[3].text, &quot;Gather 1\n&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#preamble" id="preamble">Preamble</a></h2>
<p>The script is divided into a <em>preamble</em> and the story <em>content</em>. The preamble contains
<a href="variables.html">variable declarations</a>, <a href="metadata.html">metadata</a> and inclusions of other 
documents. The content comes afterwards and can refer to declarations in the preamble.</p>
<p>The end of the preamble in a script is marked by the first line of text or story content.
This can be a divert to the introductory scene.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate inkling;
</span><span class="boring">use inkling::read_story_from_string;
</span><span class="boring">let content = r#&quot;
</span><span class="boring">
</span>// Global story tags are declared in the preamble
# title: Inkling 
# author: Petter Johansson

// ... as are global variables
CONST name = &quot;d'Artagnan&quot;
VAR rank = &quot;Capitaine&quot;

// First line of story content comes here, which ends the preamble declaration
-&gt; introduction 

=== introduction ===
I opened my notebook to a blank page, pen in hand.
<span class="boring">&quot;#;
</span><span class="boring">let story = read_story_from_string(content).unwrap();
</span><span class="boring">let tags = story.get_story_tags();
</span><span class="boring">assert_eq!(&amp;tags[0], &quot;title: Inkling&quot;);
</span><span class="boring">assert_eq!(&amp;tags[1], &quot;author: Petter Johansson&quot;);
</span><span class="boring">assert!(story.get_variable(&quot;name&quot;).is_ok());
</span><span class="boring">assert!(story.get_variable(&quot;rank&quot;).is_ok());
</span><span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../features/basic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../features/variables.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../features/basic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../features/variables.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
